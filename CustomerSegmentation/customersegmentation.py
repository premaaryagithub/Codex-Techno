# -*- coding: utf-8 -*-
"""CustomerSegmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-BxSh1edZ6xC1pflVpnk0B-qDfvLh345
"""

# uploaded dataset in Google Drive , Extracting  It from Drive itself
file_id  = '1E9TrLIlc7BBTjRUMz1Zp5NPZVG-4ZYX-'
download_url = f'https://drive.google.com/uc?id={file_id}&export=download'

# importing  pandas for data manipulation
import pandas as pd
data = pd.read_csv(download_url, encoding='latin-1')

#data display  for first five rows

data.head()

data.isnull().sum() #no null values

display(data.shape)

# check for duplicates
data.drop_duplicates


# after drop duplicates data size
display(data.shape)

"""From above observaation there is no duplicates"""

display(data.info())
# statastics of the dataset
display(data.describe())

"""Given all are in appropriate datatypes so no need to change it .."""

display(data.nunique())

#since from abive observation there is constant value columns present so we need to drop them
data.drop(columns = ['Z_CostContact','Z_Revenue'], axis=1 ,inplace= True)

display(data.shape)

""" Constant columns are removed .."""

# check for outliers }
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
numerical_cols = data.select_dtypes(include=np.number)
# Function to detect outliers using the IQR method and visualize them with boxplots
def detect_outliers_iqr(data, column, threshold=1.5):
    Q1 = data[column].quantile(0.25)
    Q3 = data[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - threshold * IQR
    upper_bound = Q3 + threshold * IQR
    outliers = data[(data[column] < lower_bound) | (data[column] > upper_bound)]
    return outliers

# Detect outliers in all numeric columns and store the count of outliers
outliers_count = {}
for column in numerical_cols.columns:
    outliers = detect_outliers_iqr(numerical_cols, column)
    outliers_count[column] = len(outliers)
# Print columns with outliers and their counts
print("Columns with outliers and their counts:")
for column, count in outliers_count.items():
    if count > 0:
        print(f"{column}: {count} outliers")

# Visualize outliers using boxplots for all numeric columns
plt.figure(figsize=(20, 15))
numerical_cols.plot(kind='box', subplots=True, layout=(6, 7), figsize=(20, 20))  # Adjust layout as needed
plt.title('Boxplots to visualize outliers')
plt.show()

"""Handling the outliers .."""

# 1. Removing outliers (careful, can lose data)
def remove_outliers_iqr(data, column, threshold=1.5):
    Q1 = data[column].quantile(0.25)
    Q3 = data[column].quantile(0.75)
    IQR = Q3 -  Q1
    lower_bound = Q1 - threshold * IQR
    upper_bound = Q3 + threshold * IQR
    # only  data within range should remains
    cleaned_data = data[(data[column] >= lower_bound) & (data[column] <= upper_bound)]
    return cleaned_data
for col in numerical_cols:
    data_after_outliers_remove = remove_outliers_iqr(data.copy(), col)
display(data.shape)
#data after  removal of outliers shape
display(data_after_outliers_remove.shape)
#show the data after outliers removal
display(data_after_outliers_remove)
display(data_after_outliers_remove.describe())

"""Now descrptive statistics of  purchase b behaviour  , frequency behaviour ..


"""

#outliers removed ..

# Descriptive Statistics
def calculate_descriptive_stats(data):
    # Basic customer metrics
    stats = {
        'Total Customers': len(data),
        'Average Age': data['Age'].mean(),
        'Average Income': data['Income'].mean(),
        'Average Household Size': (data['Kidhome'] + data['Teenhome']).mean() + 1,
        'Marital Status Distribution': data[['marital_Divorced', 'marital_Married',
                                         'marital_Single', 'marital_Together',
                                         'marital_Widow']].sum().to_dict(),
        'Education Distribution': data[['education_2n Cycle', 'education_Basic',
                                    'education_Graduation', 'education_Master',
                                    'education_PhD']].sum().to_dict()
    }

    # Purchase metrics
    purchase_stats = {
        'Average Total Spending': data['MntTotal'].mean(),
        'Average Wine Spending': data['MntWines'].mean(),
        'Average Fruit Spending': data['MntFruits'].mean(),
        'Average Meat Spending': data['MntMeatProducts'].mean(),
        'Average Fish Spending': data['MntFishProducts'].mean(),
        'Average Sweet Spending': data['MntSweetProducts'].mean(),
        'Average Gold Spending': data['MntGoldProds'].mean(),
        'Average Deal Purchases': data['NumDealsPurchases'].mean(),
        'Average Web Purchases': data['NumWebPurchases'].mean(),
        'Average Catalog Purchases': data['NumCatalogPurchases'].mean(),
        'Average Store Purchases': data['NumStorePurchases'].mean(),
        'Average Web Visits': data['NumWebVisitsMonth'].mean(),
        'Campaign Acceptance Rates': {
            'Cmp1': data['AcceptedCmp1'].mean(),
            'Cmp2': data['AcceptedCmp2'].mean(),
            'Cmp3': data['AcceptedCmp3'].mean(),
            'Cmp4': data['AcceptedCmp4'].mean(),
            'Cmp5': data['AcceptedCmp5'].mean(),
            'Any Campaign': data['AcceptedCmpOverall'].mean()
        }
    }

    return {'Customer Demographics': stats, 'Purchase Behavior': purchase_stats}

descriptive_stats = calculate_descriptive_stats(data_after_outliers_remove)

#
#Marital Status Distribution (Pie Chart with Text)
marital_status = descriptive_stats['Customer Demographics']['Marital Status Distribution']
labels = marital_status.keys()
sizes = np.array(list(marital_status.values()))
total_customers = descriptive_stats['Customer Demographics']['Total Customers']

plt.figure(figsize=(12, 6))

# Pie Chart
plt.subplot(1, 2, 1)
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.title('Marital Status Distribution')

# Textual Information
plt.subplot(1, 2, 2)
text = "Marital Status Distribution:\n"
for label, size in marital_status.items():
    percentage = (size / total_customers) * 100
    text += f"- {label}: {size} ({percentage:.1f}%)\n"
plt.text(0.1, 0.9, text, fontsize=10, verticalalignment='top')
plt.axis('off')  # Turn off axis for text

plt.tight_layout()
plt.show()

#Education Distribution (Pie Chart with Text)
education_status = descriptive_stats['Customer Demographics']['Education Distribution']
labels = education_status.keys()
sizes = np.array(list(education_status.values()))

plt.figure(figsize=(12, 6))

# Pie Chart
plt.subplot(1, 2, 1)
plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.title('Education Distribution')

# Textual Information
plt.subplot(1, 2, 2)
text = "Education Distribution:\n"
for label, size in education_status.items():
    percentage = (size / total_customers) * 100
    text += f"- {label}: {size} ({percentage:.1f}%)\n"
plt.text(0.1, 0.9, text, fontsize=10, verticalalignment='top')
plt.axis('off')

plt.tight_layout()
plt.show()

# Average Spending Amount (Bar Chart with Text)
spending_categories = ['Wine', 'Fruit', 'Meat', 'Fish', 'Sweet', 'Gold','Total']
average_spending = [descriptive_stats['Purchase Behavior'][f'Average {cat} Spending'] for cat in spending_categories]

plt.figure(figsize=(14, 6))

# Bar Chart
plt.subplot(1, 2, 1)
plt.bar(spending_categories, average_spending)
plt.title('Average Spending Amount by Product Category')
plt.xlabel('Product Category')
plt.ylabel('Average Spending Amount')
plt.xticks(rotation=45, ha="right")

# Textual Information
plt.subplot(1, 2, 2)
text = "Average Spending by Category:\n"
for cat, avg in zip(spending_categories, average_spending):
    text += f"- {cat}: ${avg:.2f}\n"
plt.text(0.1, 0.9, text, fontsize=10, verticalalignment='top')
plt.axis('off')

plt.tight_layout()
plt.show()

#Average purchase Amount (Bar chart with Text )
purchase_categories = ['Deal', 'Web', 'Catalog', 'Store']
average_purchases = [descriptive_stats['Purchase Behavior'][f'Average {cat} Purchases'] for cat in purchase_categories]

plt.figure(figsize=(14, 6))

# Bar Chart
plt.subplot(1, 2, 1)
plt.bar(purchase_categories, average_purchases)
plt.title('Average Purchase Amount by Channel')
plt.xlabel('Purchase Channel')
plt.ylabel('Average Purchase Amount')
plt.xticks(rotation=45, ha="right")

# Textual Information
plt.subplot(1, 2, 2)
text = "Average Purchase  by Category:\n"
for cat, avg in zip(purchase_categories, average_purchases):
    text += f"- {cat}: ${avg:.2f}\n"
plt.text(0.1, 0.9, text, fontsize=10, verticalalignment='top')
plt.axis('off')

plt.tight_layout()
plt.show()


# Campaign Acceptance Rates (Bar Chart with Text)
campaigns = descriptive_stats['Purchase Behavior']['Campaign Acceptance Rates'].keys()
acceptance_rates = descriptive_stats['Purchase Behavior']['Campaign Acceptance Rates'].values()

plt.figure(figsize=(14, 6))

# Bar Chart
plt.subplot(1, 2, 1)
plt.bar(campaigns, acceptance_rates)
plt.title('Campaign Acceptance Rates')
plt.xlabel('Campaign')
plt.ylabel('Acceptance Rate')
plt.xticks(rotation=45, ha="right")
plt.yticks([0, 0.1, 0.2, 0.3, 0.4, 0.5], ['0%', '10%', '20%', '30%', '40%', '50%']) # Format y-axis as percentages

# Textual Information
plt.subplot(1, 2, 2)
text = "Campaign Acceptance Rates:\n"
for campaign, rate in zip(campaigns, acceptance_rates):
    text += f"- {campaign}: {rate:.2%}\n"
plt.text(0.1, 0.9, text, fontsize=10, verticalalignment='top')
plt.axis('off')

plt.tight_layout()
plt.show()

#Customer Demographics (Side-by-Side Histograms with Text)
plt.figure(figsize=(18, 5))

# Age Distribution
plt.subplot(1, 3, 1)
plt.hist(data['Age'], bins=20, color='skyblue', edgecolor='black')
plt.title('Age Distribution')
plt.xlabel('Age')
plt.ylabel('Frequency')

# Age Statistics Text
age_stats_text = f"Average Age: {descriptive_stats['Customer Demographics']['Average Age']:.2f}"
plt.text(0.1, 0.9, age_stats_text, fontsize=10, verticalalignment='top')

# Income Distribution
plt.subplot(1, 3, 2)
plt.hist(data['Income'], bins=20, color='lightgreen', edgecolor='black')
plt.title('Income Distribution')
plt.xlabel('Income')
plt.ylabel('Frequency')

# Income Statistics Text
income_stats_text = f"Average Income: ${descriptive_stats['Customer Demographics']['Average Income']:.2f}"
plt.text(0.1, 0.9, income_stats_text, fontsize=10, verticalalignment='top')

# Household Size Distribution
plt.subplot(1, 3, 3)
household_size = data['Kidhome'] + data['Teenhome'] + 1
plt.hist(household_size, bins=10, color='lightcoral', edgecolor='black')
plt.title('Household Size Distribution')
plt.xlabel('Household Size')
plt.ylabel('Frequency')

# Household Size Statistics Text
household_stats_text = f"Average Household Size: {descriptive_stats['Customer Demographics']['Average Household Size']:.2f}"
plt.text(0.1, 0.9, household_stats_text, fontsize=10, verticalalignment='top')

plt.tight_layout()
plt.show()

"""Customer Segmentation... (k-means Clustering .. )"""

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score


def prepare_clustering_data(df):
    features = [
        'Income', 'Recency', 'MntWines', 'MntFruits', 'MntMeatProducts',
        'MntFishProducts', 'MntSweetProducts', 'MntGoldProds',
        'NumDealsPurchases', 'NumWebPurchases', 'NumCatalogPurchases',
        'NumStorePurchases', 'NumWebVisitsMonth', 'Kidhome', 'Teenhome'
    ]
  # copy main data into another data for clusters
    cluster_df = data_after_outliers_remove[features].copy()

   #  create a new column for child
    cluster_df['Child'] = cluster_df['Kidhome'] + cluster_df['Teenhome']

    # drop the above columns from original data
    cluster_df = cluster_df.drop(['Kidhome', 'Teenhome'], axis=1)

    # Standardize the data
    scaler = StandardScaler()
    scaled_data = scaler.fit_transform(cluster_df)

    return scaled_data, cluster_df.columns

def determine_optimal_clusters(data, max_k=10):
    wcss = []  # Within-cluster sum of squares
    silhouette_scores = []

    for k in range(2, max_k+1):
      #apply k-means model  to original data
        kmeans = KMeans(n_clusters=k, random_state=42)
        kmeans.fit(data)
        wcss.append(kmeans.inertia_)

        if k > 1:  # Silhouette score requires at least 2 clusters
            silhouette_scores.append(silhouette_score(data, kmeans.labels_))

    # Plot elbow method
    plt.figure(figsize=(12, 5))
    plt.subplot(1, 2, 1)
    plt.plot(range(2, max_k+1), wcss, 'bo-')
    plt.xlabel('Number of clusters')
    plt.ylabel('WCSS')
    plt.title('Elbow Method')

    # Plot silhouette scores
    plt.subplot(1, 2, 2)
    plt.plot(range(2, max_k+1), silhouette_scores, 'go-')
    plt.xlabel('Number of clusters')
    plt.ylabel('Silhouette Score')
    plt.title('Silhouette Method')

    plt.tight_layout()
    plt.show()

    return wcss, silhouette_scores
scaled_data, feature_names = prepare_clustering_data(data_after_outliers_remove)

# caluculate no of optimal clusters
wcss, silhouette_scores = determine_optimal_clusters(scaled_data)

# lets say k = 4 based on elbow point
optimal_k = 4

# Perform K-means clustering
kmeans = KMeans(n_clusters=optimal_k, random_state=42)
clusters = kmeans.fit_predict(scaled_data)

# Add cluster labels to original dataframe
data_after_outliers_remove['Cluster'] = clusters

def plot_cluster_characteristics(df, cluster_col='Cluster'):
    plt.figure(figsize=(18, 12))

    # Plot 1: Income vs Total Spending by Cluster
    plt.subplot(2, 2, 1)
    sns.scatterplot(data=df, x='Income', y='MntTotal', hue=cluster_col, palette='viridis')
    plt.title('Income vs Total Spending by Cluster')
    plt.xlabel('Income')
    plt.ylabel('Total Spending')

    # Plot 2: Purchase Channels by Cluster
    plt.subplot(2, 2, 2)
    channel_cols = ['NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases']
    channel_means = df.groupby(cluster_col)[channel_cols].mean()
    channel_means.plot(kind='bar', stacked=True, ax=plt.gca())
    plt.title('Purchase Channels by Cluster')
    plt.xlabel('Cluster')
    plt.ylabel('Average Number of Purchases')
    plt.legend(title='Channel')

    # Plot 3: Product Category Spending by Cluster
    plt.subplot(2, 2, 3)
    product_cols = ['MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts', 'MntSweetProducts', 'MntGoldProds']
    product_means = df.groupby(cluster_col)[product_cols].mean()
    product_means.plot(kind='bar', ax=plt.gca())
    plt.title('Product Category Spending by Cluster')
    plt.xlabel('Cluster')
    plt.ylabel('Average Spending')
    plt.legend(title='Product Category', bbox_to_anchor=(1.05, 1))

    # Plot 4: Household Composition by Cluster
    plt.subplot(2, 2, 4)
    household_cols = ['Kidhome', 'Teenhome']
    household_means = df.groupby(cluster_col)[household_cols].mean()
    household_means['TotalChildren'] = household_means.sum(axis=1)
    household_means.plot(kind='bar', ax=plt.gca())
    plt.title('Household Composition by Cluster')
    plt.xlabel('Cluster')
    plt.ylabel('Average Number')
    plt.legend(title='Household Member')

    plt.tight_layout()
    plt.show()

# Plot cluster characteristics
plot_cluster_characteristics(data_after_outliers_remove)

# Additional visualization: Pairplot of key features
cluster_sample = data_after_outliers_remove.sample(500) if len(data_after_outliers_remove) > 500 else data_after_outliers_remove # Sample for performance
sns.pairplot(cluster_sample,
             vars=['Income', 'MntTotal', 'NumWebPurchases', 'NumStorePurchases', 'Recency'],
             hue='Cluster',
             palette='viridis',
             plot_kws={'alpha': 0.6})
plt.suptitle('Pairplot of Key Features by Cluster', y=1.02)
plt.show()

import pandas as pd
from IPython.display import HTML

# Recommendations

recommendations = {
    "What to Do": [],
    "Action": [],
    "Expected Result": []
}

# Recommendation 1: Age-Based Marketing
recommendations["What to Do"].append("Personalize marketing by age.")
recommendations["Action"].append(
    "Create different ads for young customers (highlighting trendy items) and older customers (focusing on practical benefits)."
)
recommendations["Expected Result"].append(
    "Attract more customers across all age groups and increase sales."
)

# Recommendation 2: High-Spending Product Focus
recommendations["What to Do"].append("Promote top-selling products.")
recommendations["Action"].append(
    "Increase marketing efforts for products that customers buy most often (e.g., wines, meat) and ensure sufficient stock."
)
recommendations["Expected Result"].append(
    "Maximize profits by focusing on what already sells well."
)

# Recommendation 3: Online Experience Improvement
recommendations["What to Do"].append("Enhance the online store.")
recommendations["Action"].append(
    "Make the website easier to use, give personalized product suggestions, and simplify the checkout process."
)
recommendations["Expected Result"].append(
    "Boost online sales and make customers happier with shopping online."
)

# Recommendation 4: Loyalty Program
recommendations["What to Do"].append("Reward loyal customers.")
recommendations["Action"].append(
    "Start a program that gives special discounts or gifts to customers who buy frequently or spend a lot."
)
recommendations["Expected Result"].append(
    "Encourage customers to keep coming back and increase long-term sales."
)

# Create DataFrame
df_simple_recs = pd.DataFrame(recommendations)

# Display the DataFrame in the notebook-like format
display(HTML(df_simple_recs.to_html(index=False)))

